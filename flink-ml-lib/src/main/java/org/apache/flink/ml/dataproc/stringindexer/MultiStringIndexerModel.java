/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.ml.dataproc.stringindexer;

import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.typeutils.RowTypeInfo;
import org.apache.flink.ml.api.core.Model;
import org.apache.flink.ml.common.broadcast.BroadcastUtils;
import org.apache.flink.ml.common.broadcast.operator.HasBroadcastVariable;
import org.apache.flink.ml.param.Param;
import org.apache.flink.ml.param.dataproc.HasHandleInvalid;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.operators.AbstractStreamOperator;
import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
import org.apache.flink.table.api.Table;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;
import org.apache.flink.table.api.internal.TableImpl;
import org.apache.flink.types.Row;
import org.apache.flink.util.Preconditions;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

/**
 * Map string to index based on the model generated by {@link MultiStringIndexer}.
 */
public class MultiStringIndexerModel implements Model<MultiStringIndexerModel>,
        MultiStringIndexerParams<MultiStringIndexerModel> {
    private final Map<Param<?>, Object> paramMap = new HashMap<>();
    private DataStream<Row> modelStream;
    private static final String broadcastModelKey = "MultiStringIndexerModelStream";

    @Override
    public Table[] transform(Table... inputs) {
        Preconditions.checkNotNull(getSelectedCols());
        Preconditions.checkNotNull(getOutputCols());
        Preconditions.checkArgument(getOutputCols().length == getSelectedCols().length);
        Preconditions.checkArgument(getOutputCols().length > 0);
        Preconditions.checkArgument(inputs[0].getResolvedSchema().getColumnNames().containsAll(Arrays.asList(getSelectedCols())));
        Preconditions.checkArgument(getReservedCols() == null || inputs[0].getResolvedSchema().getColumnNames().containsAll(Arrays.asList(getReservedCols())));

        StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();
        DataStream<Row> input = tEnv.toDataStream(inputs[0]);

        Map<String, DataStream<?>> broadcastMap = new HashMap<>();
        broadcastMap.put(broadcastModelKey, this.modelStream);

        String[] reservedCols = getReservedCols() == null ? new String[0] : getReservedCols();
        int reservedColSize = reservedCols.length;
        String[] outputCols = getOutputCols();
        int outputColSize = outputCols.length;
        int outputSchemaSize = reservedColSize + outputColSize;

        TypeInformation<?>[] typeInformations = new TypeInformation[outputSchemaSize];
        for (int i = 0; i < reservedColSize; i++) {
            int index = inputs[0].getResolvedSchema().getColumnNames().indexOf(reservedCols[i]);
            typeInformations[i] = TypeInformation.of(inputs[0].getResolvedSchema().getColumnDataTypes().get(index).getConversionClass());
        }
        Arrays.fill(typeInformations, reservedColSize, outputSchemaSize, TypeInformation.of(Long.class));

        String[] columnNames = new String[outputSchemaSize];
        System.arraycopy(reservedCols, 0, columnNames, 0, reservedColSize);
        System.arraycopy(outputCols, 0, columnNames, reservedColSize, outputColSize);

        Function<List<DataStream<?>>, DataStream<Row>> function = dataStreams -> {
            DataStream stream = dataStreams.get(0);
            return stream.transform(
                    this.getClass().getSimpleName(),
                    new RowTypeInfo(typeInformations, columnNames),
                    new PredictOperator(getSelectedCols(), outputCols, reservedCols, getHandleInvalid())
            );
        };

        DataStream<Row> output = BroadcastUtils.withBroadcastStream(Collections.singletonList(input), broadcastMap, function);
        return new Table[]{tEnv.fromDataStream(output)};
    }

    @Override
    public void save(String path) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Map<Param<?>, Object> getUserDefinedParamMap() {
        return paramMap;
    }

    @Override
    public void setModelData(Table... inputs) {
        StreamTableEnvironment tEnv = (StreamTableEnvironment) ((TableImpl) inputs[0]).getTableEnvironment();
        modelStream = tEnv.toDataStream(inputs[0]);
    }

    private static class PredictOperator extends AbstractStreamOperator<Row>
            implements OneInputStreamOperator<Row, Row>, HasBroadcastVariable {
        private MultiStringIndexerModelData modelData;
        private final String[] selectedCols;
        private final String[] outputCols;
        private final String[] reservedCols;
        private final HasHandleInvalid.HandleInvalid handleInvalid;

        private PredictOperator(String[] selectedCols, String[] outputCols, String[] reservedCols, HandleInvalid handleInvalid) {
            this.selectedCols = selectedCols;
            this.outputCols = outputCols;
            this.reservedCols = reservedCols;
            this.handleInvalid = handleInvalid;
        }

        @Override
        public void setBroadcastVariable(String name, List<?> broadcastVariable) {
            if (name.equals(broadcastModelKey)) {
                modelData = new MultiStringIndexerModelData();
                modelData.indexMapper = new HashMap<>();
                for (Object obj: broadcastVariable) {
                    Row row = (Row) obj;
                    row = (Row) row.getField(0);
                    String colName = selectedCols[(Integer) row.getField(0)];
                    Object key = row.getField(1);
                    Long value = (Long) row.getField(2);
                    if (!modelData.indexMapper.containsKey(colName)) {
                        modelData.indexMapper.put(colName, new HashMap<>());
                    }
                    Map<Object, Long> map = modelData.indexMapper.get(colName);
                    map.put(key, value);
                }
            }
        }

        @Override
        public void processElement(StreamRecord<Row> streamRecord) {
            Row row = streamRecord.getValue();
            Row result = Row.withNames();
            for (String colName: this.reservedCols) {
                Object value = row.getField(colName);
                result.setField(colName, value);
            }

            for (int i = 0; i < selectedCols.length; i++) {
                Object oriValue = row.getField(selectedCols[i]);
                if (oriValue == null) {
                    result.setField(outputCols[i], null);
                    continue;
                }

                Long value = modelData.indexMapper.get(selectedCols[i]).get(oriValue);
                if (value == null) {
                    switch (this.handleInvalid) {
                        case KEEP:
                            result.setField(outputCols[i], (long) modelData.indexMapper.get(selectedCols[i]).size());
                            continue;
                        case SKIP:
                            result.setField(outputCols[i], null);
                            continue;
                        case ERROR:
                            throw new RuntimeException("Unknown token: " + value);
                        default:
                            throw new UnsupportedOperationException("Unsupported HandleInvalid Strategy: " + this.handleInvalid.name());
                    }
                }
                result.setField(outputCols[i], value);
            }

            output.collect(new StreamRecord<>(result));
        }
    }
}
